import{_ as n,c as t,o as i,ae as o}from"./chunks/framework.B1NSY5dd.js";const u=JSON.parse('{"title":"Introduction","description":"","frontmatter":{},"headers":[],"relativePath":"guide/introduction.md","filePath":"guide/introduction.md"}'),a={name:"guide/introduction.md"};function r(c,e,s,d,l,p){return i(),t("div",null,[...e[0]||(e[0]=[o('<h1 id="introduction" tabindex="-1">Introduction <a class="header-anchor" href="#introduction" aria-label="Permalink to &quot;Introduction&quot;">​</a></h1><p><code>light-di</code> is a simple, lightweight dependency injection (DI) container designed for modern JavaScript and TypeScript applications. It helps you write cleaner, more maintainable, and easily testable code by decoupling components and managing their dependencies.</p><h2 id="why-use-a-dependency-injection-container" tabindex="-1">Why use a Dependency Injection Container? <a class="header-anchor" href="#why-use-a-dependency-injection-container" aria-label="Permalink to &quot;Why use a Dependency Injection Container?&quot;">​</a></h2><p>In modern software development, applications are often built from many smaller, independent components. A dependency injection container helps manage the lifecycle and dependencies of these components. This leads to:</p><ul><li><strong>Decoupled Code</strong>: Components don&#39;t create their own dependencies; they are &quot;injected&quot; from the outside. This makes it easier to replace dependencies, for example, with mock objects during testing.</li><li><strong>Improved Testability</strong>: Since dependencies can be easily mocked, unit testing becomes much simpler.</li><li><strong>Better Code Organization</strong>: DI containers encourage better architectural patterns and a more organized codebase.</li></ul><h2 id="core-concepts" tabindex="-1">Core Concepts <a class="header-anchor" href="#core-concepts" aria-label="Permalink to &quot;Core Concepts&quot;">​</a></h2><p><code>light-di</code> is built around a few core concepts:</p><ul><li><strong>Container</strong>: The <code>Container</code> is the heart of the library. It manages the registration and resolution of services.</li><li><strong>Services</strong>: A service is typically a class that provides some functionality. Services can depend on other services.</li><li><strong>Lifecycle</strong>: <code>light-di</code> supports two lifecycles for services: <ul><li><code>singleton</code>: A single instance of the service is created and shared throughout the application.</li><li><code>transient</code>: A new instance of the service is created every time it is resolved.</li></ul></li></ul>',8)])])}const m=n(a,[["render",r]]);export{u as __pageData,m as default};
